<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Test of the D3 framework</title>
    <script src="d3v3/d3.v3.min.js"></script>
    <script src="kernel/framework.js"></script>
    <script src="d3-path/d3-path.min.js"></script>
  </head>

  <body>
    <script type="text/javascript" ,src="framework.js">


    var worldHeight = 1000;
    var worldWidth = 1000;

    var svg = d3.select("body").append("svg")
      .attr("width", worldWidth)
      .attr("height",worldHeight);

    // Z direction INTO screen

    let boxWidth = 800;
    let boxHeight = 800;
    let boxDepth = 800;
    let boxCentreX = -boxWidth/2; // in local coordinates
    let boxCentreY = boxHeight/2; // in local coordinates

    // centred coordinates of the perspective point
    var xp = screenToCentreX(0);
    var yp = screenToCentreY(0);
    let zp = (2*boxDepth);

    // coordinates of box edges
    var leftBoxEdge = function(r){return -boxWidth/2 + r;}
    var rightBoxEdge = function(r){return boxWidth/2 - r;}

    var upperBoxEdge = function(r){return boxHeight/2 - r;}
    var lowerBoxEdge = function(r){return -boxHeight/2 + r;}

    var outerBoxEdge = function(r){return boxDepth/2 - r;}
    var innerBoxEdge = function(r){return (-boxDepth/2) + r;}

    var lineFunction = d3.svg.line()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; })
      .interpolate('linear');

    var a = (1-((boxDepth)/Math.abs((boxDepth/2)-zp)));
    var b = (1-((boxDepth)/Math.abs((-boxDepth/2)-zp)));

    var edges = createCentredCube(boxWidth,zp);

    var boxColour = "rgba(255,255,255,1)";
    var boxStroke = "black";

    edges.slice(0,1).forEach(function(d){
      svg.append("path")
        .attr("d", lineFunction(d))
        .attr("stroke", boxStroke)
        .attr("stroke-width", 0.7)
        .attr("fill", boxColour);
    })

    var pendulumData = [
      {
        hx:0, // hinge x
        hy:boxHeight/2, //hinge y
        hz:0, // hinge z
        x:0,  // bob x
        y:0,  // bob y
        z:0,  // bob z
        r:20,  // radius
        m:1,  // bob mass
        a:50, // amplitude

        scale: function(){
          return zFactor(boxDepth,this.z,zp);
        },

        ix: function(){
          return this.x * this.scale();
        },
        iy: function(){
          return this.y * this.scale();
        },
        ir: function(){
          return this.r * this.scale();
        },
        s: function(){
            return [{x:centreToScreenX(this.hx*this.scale()),y:centreToScreenY(this.hy*this.scale())},{x:centreToScreenX(this.x*this.scale()),y:centreToScreenY(this.y*this.scale())}];
          },
        theta: function(){
          return Math.atan(Math.abs(this.x-this.hx)/Math.abs(this.y - this.hy));
        }


      },
    ];



    var group1 = svg.append("g");
    var string = group1.selectAll("path").data(pendulumData);
    var pendulum = d3.select("svg").selectAll("circle").data(pendulumData);

    pendulum.enter()
      .append("circle")
      .attr("r",function(d){return d.ir()})
      .attr("cx",function(d){return centreToScreenX(d.ix())})
      .attr("cy", function(d){return centreToScreenY(d.iy())})
      .attr("fill", "red");

    string.enter()
      .append("path")
      .attr("stroke", "red")
      .attr("stroke-width", 1)
      .attr("fill", "none");

    var timeInfo = d3.select("svg")
      .append("text")
      .attr("x",screenToCentreX(boxCentreX*b))
      .attr("y", screenToCentreY((-boxCentreY-25)*b))
      .attr("fill","none")
      .attr("stroke","black");

      d3.timer( function(duration) {
        var interval = duration*0.001;
        pendulum.data(function(d) {
          pendulumData.forEach(
            function (d,i,data){
              d.x = d.m*(-0.981)*Math.sin(d.theta());
              d.y = d.a*Math.cos(interval);

              string.attr("d", lineFunction(d.s()))


            }

          );
          return pendulumData;
        });

        pendulum.attr("cx",function(d){return centreToScreenX(d.ix())});
        pendulum.attr("cy",function(d){return centreToScreenY(d.iy())});
        pendulum.attr("r", function(d){return d.ir()});


        timeInfo.text(function(){return "time elapsed: " + (duration*0.001).toFixed(2) + "s"})
        return false;
      });
    </script>
  </body>
</html>
