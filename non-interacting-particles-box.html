<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Test of the D3 framework</title>
  <script src="d3v3/d3.v3.min.js"></script>
  <script src="kernel/framework.js"></script>
  <script src="d3-path/d3-path.min.js"></script>
  </head>

  <body>
    <script type="text/javascript">

    /*
      create an svg canvas
    */

    var worldHeight = 1000;
    var worldWidth = 1000;

    var svg = d3.select("body").append("svg")
      .attr("width", worldWidth)
      .attr("height",worldHeight);

    /*
      create a box onto the svg canvas
    */

    // Z direction INTO screen

    var boxWidth = 700;
    var boxHeight = 700;
    var boxDepth = 700;
    var boxCentreX = -boxWidth/2; // in local coordinates
    var boxCentreY = boxHeight/2; // in local coordinates
    var particleSize = 8;
    var particleSizeMin = particleSize/4;

    var xp = screenToCentreX(0);
    var yp = screenToCentreY(0);
    var zp = (2*boxDepth);

    let N = 50

    // coordinates of box edges
    var leftBoxEdge = function(r){return -boxWidth/2 + r;}
    var rightBoxEdge = function(r){return boxWidth/2 - r;}

      var upperBoxEdge = function(r){return boxHeight/2 - r;}
    var lowerBoxEdge = function(r){return -boxHeight/2 + r;}


    var outerBoxEdge = function(r){return boxDepth/2 - r;}
    var innerBoxEdge = function(r){return (-boxDepth/2) + r;}

    var worldBox = d3.select("svg")
      .append("rect")
      .attr("width", worldWidth)
      .attr("height", worldHeight)
      .attr("x", 0)
      .attr("y",0)
      .attr("fill", "none")
      .attr("stroke","none");

      //This is the accessor function we talked about above
    var lineFunction = d3.svg.line()
      .x(function(d) { return d.x; })
      .y(function(d) { return d.y; })
      .interpolate('linear');

    var a = (1-((boxDepth)/Math.abs((boxDepth/2)-zp)));
    var b = (1-((boxDepth)/Math.abs((-boxDepth/2)-zp)));

    //The data for our line
    var topEdge = [
      { x: centreToScreenX(-boxWidth/2 * a),   y: centreToScreenY(boxHeight/2 * a)},
      { x: centreToScreenX(-boxWidth/2 * b),  y: centreToScreenY(boxHeight/2 * b)},
      { x: centreToScreenX(boxWidth/2 * b),  y: centreToScreenY(boxHeight/2 * b)},
      { x: centreToScreenX(boxWidth/2 * a),  y: centreToScreenY(boxHeight/2 * a)},
      { x: centreToScreenX(-boxWidth/2 * a),  y: centreToScreenY(boxHeight/2 * a)},
    ];

    var leftEdge = [
      { x: centreToScreenX(-boxWidth/2 * a ),   y: centreToScreenY(boxHeight/2 * a)},
      { x: centreToScreenX(-boxWidth/2 * b),  y: centreToScreenY(boxHeight/2 * b)},
      { x: centreToScreenX(-boxWidth/2 * b),  y: centreToScreenY(-boxHeight/2 * b)},
      { x: centreToScreenX(-boxWidth/2 * a),  y: centreToScreenY(-boxHeight/2 * a)},
      { x: centreToScreenX(-boxWidth/2 * a),  y: centreToScreenY(boxHeight/2  * a)},
    ];

    var bottomEdge = [
      { x: centreToScreenX(-boxWidth/2 * a),   y: centreToScreenY(-boxHeight/2 * a)},
      { x: centreToScreenX(-boxWidth/2 * b),  y: centreToScreenY(-boxHeight/2 * b)},
      { x: centreToScreenX(boxWidth/2 * b),  y: centreToScreenY(-boxHeight/2 * b)},
      { x: centreToScreenX(boxWidth/2 * a),  y: centreToScreenY(-boxHeight/2 * a)},
      { x: centreToScreenX(-boxWidth/2 * a),  y: centreToScreenY(-boxHeight/2 * a)},
    ];

    var rightEdge = [
      { x: centreToScreenX(boxWidth/2 * a),   y: centreToScreenY(-boxHeight/2 * a)},
      { x: centreToScreenX(boxWidth/2 * b),  y: centreToScreenY(-boxHeight/2 * b)},
      { x: centreToScreenX(boxWidth/2 * b),  y: centreToScreenY(boxHeight/2 * b)},
      { x: centreToScreenX(boxWidth/2 * a),  y: centreToScreenY(boxHeight/2 * a)},
      { x: centreToScreenX(boxWidth/2 * a),  y: centreToScreenY(-boxHeight/2 * a)},
    ];

    var innerEdge = [
      { x: centreToScreenX(-boxWidth/2 * a),   y: centreToScreenY(-boxHeight/2 * a)},
      { x: centreToScreenX(-boxWidth/2 * a),  y: centreToScreenY(boxHeight/2 * a)},
      { x: centreToScreenX(boxWidth/2 * a),  y: centreToScreenY(boxHeight/2 * a)},
      { x: centreToScreenX(boxWidth/2 * a),  y: centreToScreenY(-boxHeight/2 * a)},
      { x: centreToScreenX(-boxWidth/2 * a),  y: centreToScreenY(-boxHeight/2 * a)},
    ]

    //The line SVG Path we draw
    var drawTopEdge = svg.append("path")
      .attr("d", lineFunction(topEdge))
      .attr("stroke", "white")
      .attr("stroke-width", 0.7)
      .attr("fill", "rgba(0,0,0,1)");

    var drawBottomEdge = svg.append("path")
      .attr("d", lineFunction(bottomEdge))
      .attr("stroke", "white")
      .attr("stroke-width", 0.7)
      .attr("fill", "rgba(0,0,0,1)");

    var drawLeftEdge = svg.append("path")
      .attr("d", lineFunction(leftEdge))
      .attr("stroke", "white")
      .attr("stroke-width", 0.7)
      .attr("fill", "rgba(0,0,0,1)");

    var drawRightEdge = svg.append("path")
      .attr("d", lineFunction(rightEdge))
      .attr("stroke", "white")
      .attr("stroke-width", 0.7)
      .attr("fill", "rgba(0,0,0,1)");

    var drawInnerEdge = svg.append("path")
      .attr("d", lineFunction(innerEdge))
      .attr("stroke", "white")
      .attr("stroke-width", 0.7)
      .attr("fill", "rgba(0,0,0,1)");



    var data = new Array;
    for (var i = 0; i < N; i++){
      n = {
        vx: randomNumber(-40,40),
        vy: randomNumber(-40,40),
        vz: randomNumber(-40,40),
        px: randomNumber(leftBoxEdge(particleSize), rightBoxEdge(particleSize)),
        py: randomNumber(upperBoxEdge(particleSize), lowerBoxEdge(particleSize)),
        pz: randomNumber(upperBoxEdge(particleSize), lowerBoxEdge(particleSize)),
        r: particleSize,
        ix: 0,
        iy: 0,
        ir: 0,
        m: 1
      }
      data.push(n);
    }
    var particleData = data;
    var particle = d3.select("svg").selectAll("circle").data(particleData);

    particle.enter().append("circle")
      .attr("cy", function (d){ return screenToCentreY(d.py)})
      .attr("cx", function (d){ return screenToCentreX(d.px)})
      .attr("r",particleSize)
      .attr("stroke","black")
      .attr("fill","white");

    var timeInfo = d3.select("svg")
      .append("text")
      .attr("x",screenToCentreX(boxCentreX*b))
      .attr("y", screenToCentreY((-boxCentreY-25)*b))
      .attr("fill","none")
      .attr("stroke","black");

    var miscInfo = d3.select("svg")
      .append("text")
      .attr("x",screenToCentreX(boxCentreX*b))
      .attr("y", screenToCentreY((-boxCentreY-50)*b))
      .attr("fill","none")
      .attr("stroke","black");

      svg.append("circle")
          .attr("r",2)
          .attr("cx",xp)
          .attr("cy",yp)
          .attr("fill","red");

    var globalTime = 0;
    let dt = 0.0001;
    let gx = 0//9.81*0.1
    let gy = -9.81*0.1
    let gz = 0//9.81*0.1;
    let cOfR = 0.8; // Coefficient of Restitution

    // runs the simulation
    d3.timer( function(duration) {
      var interval = duration*0.0001;

      particle.data(function(d) {
        particleData.forEach(
          function (d,i,data){
            exchangeMomenta(d,i,particleData, 1);
            updateVerletV(d,interval,gx,gy,gz);
            updateVerletP(d,interval,gx,gy,gz);

            var scaleFactor = (1-((boxDepth)/Math.abs(d.pz-zp)));
            d.ix = d.px*scaleFactor;
            d.iy = d.py*scaleFactor;
            d.ir = d.r*scaleFactor;

            var upperLim = upperBoxEdge(d.r);
            var lowerLim = lowerBoxEdge(d.r);
            var leftLim = leftBoxEdge(d.r);
            var rightLim = rightBoxEdge(d.r);
            var outerLim = outerBoxEdge(d.r);
            var innerLim = innerBoxEdge(d.r);

            if( d.py >= upperLim ) {
              d.py = upperLim;
              d.vy = -1*d.vy*cOfR;
            };

            if( d.py <= lowerLim ) {
              d.py = lowerLim ;
              d.vy = -1*d.vy*cOfR;
            };

            if( d.px <= leftLim ) {
              d.px = leftLim;
              d.vx = -1*d.vx*cOfR;
            };

            if( d.px >= rightLim ) {
              d.px = rightLim;
              d.vx = -1*d.vx*cOfR;
            };

            if( d.pz <= innerLim ) {
              d.vz = -1*d.vz*cOfR;
              d.pz = innerLim;
            };

            if( d.pz >= outerLim ) {
              d.vz = -1*d.vz*cOfR;
              d.pz = outerLim;
            };
          }
        );
        return particleData;
      });

    particle.attr("cx", function(d, i) {
      return centreToScreenX(d.ix);});

    particle.attr("cy", function(d, i) {
      return centreToScreenY(d.iy); });

    particle.attr("r", function(d,i) {
      return d.ir;})

    timeInfo.text(function () {return "time elapsed: " + (duration*0.001).toFixed(2) + "s"})
    miscInfo.text(function () {
    return "N:\n" + N + " " +
    "gravity: " + gy.toFixed(3) + " ms^2"
      });
    return false;
    });
    </script>
  </body>
</html>
